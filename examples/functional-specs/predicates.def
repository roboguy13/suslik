predicate transformation_list(loc x, set preS, set postS, pred p) {
|  x == null        => { preS =i {} && postS =i {} ; emp }
|  not (x == null)  => { preS =i {v} ++ preS1 && postS =i {r} ++ postS1 && p(v, r) ; [x, 2] ** x :-> r ** (x + 1) :-> nxt ** transformation_list(nxt, preS1, postS1, p) }
}

predicate list_relation(loc x, loc y, set preS, set postS, pred p) {
|  x == null       => { preS =i {} && postS =i {} && y == null ; emp }
|  not (x == null) => { preS =i {xV} ++ preS1 && postS =i {yV} ++ postS1 && p(xV, yV)
      ;
      [x, 2] ** [y, 2] ** x :-> xV ** y :-> yV ** (x+1) :-> xNxt ** (y+1) :-> yNxt **
      list_relation(xNxt, yNxt, preS1, postS1, p) }
}

predicate constrained_list(loc x, set s, pred p) {
|  x == null        => { s =i {} ; emp }
|  not (x == null)  => { s =i {v} ++ s1 && p(v, r) ; [x, 2] ** x :-> r ** (x + 1) :-> nxt ** constrained_list(nxt, s1, p) }
}

synonym unconstrained(loc x, set s) {
  constrained_list(x, s, pred(u, v) => u == v)
}

predicate spatially_constrained(loc x, set s, pred p) {
|  x == null        => { s =i {} ; emp }
|  not (x == null)  => { s =i {v} ++ s1 ; p(x) ** [x, 2] ** x :-> r ** (x + 1) :-> nxt ** constrained_list(nxt, s1, p) }
}

predicate unfold(loc x, set s, int curr, pred stopCond, pred p) {
|  stopCond(curr) => { emp }
}


predicate foldI(loc x, set s, int acc, int z, pred p) {
|  x == null => { acc == z; emp }
|  not (x == null) => {
    p(acc, v, acc1) && s =i {v} ++ s1
      ;
    [x, 2] ** x :-> v ** (x + 1) :-> nxt ** foldI(nxt, s1, acc1, z, p) }
}

predicate foldMap(loc x, set s, int acc, int z, pred mapFn, pred foldFn) {
|  x == null       => { acc == z && s =i {} ; emp }
|  not (x == null) => {
     s =i {v} ++ s1 && mapFn(v, mapResult) && foldFn(acc, mapResult, acc1)
       ;
     [x, 2] ** x :-> v ** (x+1) :-> nxt ** foldMap(nxt, s1, acc1, z, mapFn, foldFn)
    }
}

predicate digit(loc x, loc a, loc b, loc c) {
| true => { [x,3] ** x :-> a ** (x+1) :-> b ** (x+2) :-> c }
}

predicate pair(loc x, int a, int b) {
| true => { [x, 2] ** x :-> a ** (x+1) :-> b }
}

predicate zipped(loc x, loc y, loc r, set lefts, set rights) {
| x == 0 || y == 0 => { lefts =i {} && rights =i {} ; emp }
| not (x == 0 || y == 0) => {
    lefts =i {a} ++ lefts1 &&
    rights =i {b} ++ rights1
      ;
    x :-> a ** (x+1) :-> nxtX **
    y :-> b ** (y+1) :-> nxtY **
    [r, 2] ** pair(p, a, b) ** r :-> p ** (r+1) :-> nxtR ** zipped(nxtX, nxtY, nxtR, lefts1, rights1)
  }
}

predicate filter_gt_7(loc x, set preS, set postS) {
| x == null => { preS =i {} && postS =i {} ; emp }
| not (x == null) && preS =i {v} ++ preS1 && postS =i {v} ++ postS1 && v > 7 => { 
    [x, 2] ** x :-> v ** (x+1) :-> nxt ** filter_gt_7(nxt, preS1, postS1)
    }
| not (x == null) && preS =i {v} ++ preS1 && not (v > 7) => { [x, 1] ** x :-> nxt ** filter_gt_7(nxt, preS1, postS) }
}

// synonym foldMap2(loc x, set s, int acc, int z, pred mapFn, pred foldFn) {
//   
// }

// synonym pair_list(loc x, set lefts, set rights) {
//   spatially_constrained
// }

// predicate pairwise_sum(loc x, loc y, set s) {
// }

// synonym foldMap(loc x, set s, int acc, int z, pred mapFn, pred foldFn) {
//   join(foldI[x, s, acc, z, foldFn[_, ?mapResult, _]], constrained_list[x, s, mapFn[_, ?mapResult]])
// }

// predicate foldMap'(loc x, loc s, int acc, int z, pred mapFn, pred foldFn) {
// |  x == null => { acc == z ; emp }
// |  not (x == null) => {
//     s =i {v} ++ s1 && mapFn(v, mapResult) ; [x, 2] ** x :-> r ** (x + 1) :-> nxt ** constrained_list(nxt, s1, p)
//    }
// }


//    predicate foldMap_generated(loc x, set s, int acc, int z, pred mapFn, pred foldFn) {
//    | x == null => { acc == z && s =i {} ; emp }
//    | not (x == null) => {
//         s =i {v} ++ s1
//         && mapFn(v, mapResult)
//         && foldFn(acc, mapResult, acc1)
//           ;
//         [x, 2] ** x :-> mapResult ** (x + 1) :-> nxt ** foldMap_generated(nxt, s1, acc1, z, mapFn, foldFn)
//      }
//    }

predicate reify(loc x, int i) {
| true => { [x, 1] ** x :-> i }
}

