predicate transformation_list(loc x, set preS, set postS, pred p) {
|  x == null        => { preS =i {} && postS =i {} ; emp }
|  not (x == null)  => { preS =i {v} ++ preS1 && postS =i {r} ++ postS1 && p(v, r) ; [x, 2] ** x :-> r ** (x + 1) :-> nxt ** transformation_list(nxt, preS1, postS1, p) }
}

predicate list_relation(loc x, loc y, set preS, set postS, pred p) {
|  x == null       => { preS =i {} && postS =i {} && y == null ; emp }
|  not (x == null) => { preS =i {xV} ++ preS1 && postS =i {yV} ++ postS1 && p(xV, yV)
      ;
      [x, 2] ** [y, 2] ** x :-> xV ** y :-> yV ** (x+1) :-> xNxt ** (y+1) :-> yNxt **
      list_relation(xNxt, yNxt, preS1, postS1, p) }
}



// TODO: See if this can work
predicate fold_with(loc x, loc y, int curr, set s, pred p) {
| x == null => { y == null ; emp}
| not (x == null) => {
    s =i {curr} ++ s1 &&
    p(old, curr)
      ;
    [x, 2] **
    x :-> old **
    (x+1) :-> xNxt **
    [y, 2] **
    y :-> curr **
    (y+1) :-> yNxt **
    fold_with(xNxt, yNxt, curr, s1, p)
  }
}

// predicate accum_list_relation(loc x, loc y, int last, set preS, set postS, pred p) {
// | x == null => { preS =i {} && postS =i {} && y == null ; emp }
// }

predicate constrained_list(loc x, set s, pred p) {
|  x == null        => { s =i {} ; emp }
|  not (x == null)  => { s =i {v} ++ s1 && p(v, r) ; [x, 2] ** x :-> r ** (x + 1) :-> nxt ** constrained_list(nxt, s1, p) }
}

predicate sll(loc x, set s) {
| x == null => { s =i {} ; emp }
| not (x == null) => {
    s =i {v} ++ s1
      ;
    [x, 2] ** x :-> v ** (x+1) :-> nxt **
    sll(nxt, s1)
  }
}

predicate snoc_list(loc x, set s) {
| x == null => { s =i {} ; emp }
| not (x == null) => { s =i {v} ++ s1 ; [x, 2] ** x :-> nxt ** (x+1) :-> v ** snoc_list(nxt, s1) }
}

predicate assoc_list(loc x, set keys, set vals) {
| x == null => { keys =i {} && vals =i {} ; emp }
| not (x == null) => {
    keys =i {k} ++ keys1 &&
    vals =i {v} ++ vals1
      ;
    [x, 3] **
    x :-> k **
    (x+1) :-> v **
    (x+2) :-> nxt **
    assoc_list(nxt, keys1, vals1)
  }
}

synonym unconstrained(loc x, set s) {
  constrained_list(x, s, pred(u, v) => u == v)
}

synonym fill(loc x, set s, int val) {
  constrained_list(x, s, pred(unused, new) => new == val)
}

predicate sll(loc x, set s) {
| x == null => { s =i {} ; emp }
| not (x == null) => { s =i {v} ++ s1 ; [x, 2] ** x :-> v ** (x+1) :-> nxt ** sll(nxt, s1) }
}

predicate nonempty(loc x, set s) {
| not (x == null) => { s =i {v} ++ s1 ; [x, 2] ** x :-> v ** (x+1) :-> nxt ** sll(nxt, s1) }
}

// predicate last(loc x, loc y, set s) {
// | 
// }

predicate subsets(loc x, set inS, set outS) {
| x == null => { inS =i {} && outS =i {} ; emp }
| not (x == null) => { outS =i {v} ++ inS1 ++ outS1
    ;
    [x, 2] **
    x :-> v **
    (x+1) :-> nxt **
    subsets(nxt, inS1, outS1)
  }
}

predicate take(int n, loc x, set s) {
| n == 0 || x == null => { s =i {} ; emp }
| not (n == 0 || x == null) => { s =i {v} ++ s1
    ;
    [x, 2] **
    x :-> v **
    (x+1) :-> nxt **
    take(n-1, nxt, s1)
  }
}

predicate subseq_of(loc xs, set subsetS, set s) {
| xs == null => { subsetS =i {} ; emp }
| not (xs == null) => {
    subsetS =i {v} ++ subsetS1 && v in s
      ;
    [x, 2] **
    x :-> v **
    (x+1) :-> nxt **
    subseq_of(nxt, subsetS1, s - {v})
  }
}

predicate map_pred(loc x, set s, pred p) {
| x == null => { s =i {} ; emp }
| not (x == null) => {
    s =i {v} ++ s1
      ;
    p(v) **
    [x, 2] **
    x :-> v **
    (x+1) :-> nxt **
    map_pred(nxt, s1, p)
  }
}


predicate spatially_constrained(loc x, set s, pred p) {
|  x == null        => { s =i {} ; emp }
|  not (x == null)  => { s =i {v} ++ s1 ; p(x) ** [x, 2] ** x :-> r ** (x + 1) :-> nxt ** constrained_list(nxt, s1, p) }
}

predicate unfold(loc x, int curr, pred stopCond, pred p) {
| stopCond(curr) => { emp }
| not stopCond(curr) => {
    p(curr, newCurr)
      ;
    [x, 2] **
    x :-> curr ** (x+1) :-> nxt **
    unfold(nxt, newCurr, stopCond, p)
  }
}

predicate wrapped_leaf_tree(loc x, set s) {
| true => { x :-> tag ** leaf_tree(x, tag, s) }
}

predicate leaf_tree(loc x, int tag, set s) {
| tag == 0 => { s =i {v} ; [x, 2] ** (x+1) :-> v }
| tag == 1 => {
    s =i sL ++ sR
      ;
    [x, 3] **
    (x+1) :-> left **
    (x+2) :-> right **
    wrapped_leaf_tree(left, sL) **
    wrapped_leaf_tree(right, sR)
  }
}


predicate foldI(loc x, set s, int acc, int z, pred p) {
|  x == null => { acc == z; emp }
|  not (x == null) => {
    p(acc, v, acc1) && s =i {v} ++ s1
      ;
    [x, 2] ** x :-> v ** (x + 1) :-> nxt ** foldI(nxt, s1, acc1, z, p) }
}

predicate foldMap(loc x, set s, int acc, int z, pred mapFn, pred foldFn) {
|  x == null       => { acc == z && s =i {} ; emp }
|  not (x == null) => {
     s =i {v} ++ s1 && mapFn(v, mapResult) && foldFn(acc, mapResult, acc1)
       ;
     [x, 2] ** x :-> v ** (x+1) :-> nxt ** foldMap(nxt, s1, acc1, z, mapFn, foldFn)
    }
}

predicate digit(loc x, loc a, loc b, loc c) {
| true => { [x,3] ** x :-> a ** (x+1) :-> b ** (x+2) :-> c }
}

predicate pair(loc x, int a, int b) {
| true => { [x, 2] ** x :-> a ** (x+1) :-> b }
}

predicate zipped(loc x, loc y, loc r, set lefts, set rights) {
| x == 0 || y == 0 => { lefts =i {} && rights =i {} ; emp }
| not (x == 0 || y == 0) => {
    lefts =i {a} ++ lefts1 &&
    rights =i {b} ++ rights1
      ;
    x :-> a ** (x+1) :-> nxtX **
    y :-> b ** (y+1) :-> nxtY **
    [r, 2] ** pair(p, a, b) ** r :-> p ** (r+1) :-> nxtR ** zipped(nxtX, nxtY, nxtR, lefts1, rights1)
  }
}

predicate filter_gt_7(loc x, set preS, set postS) {
| x == null => { preS =i {} && postS =i {} ; emp }
| not (x == null) && preS =i {v} ++ preS1 && postS =i {v} ++ postS1 && v > 7 => { 
    [x, 2] ** x :-> v ** (x+1) :-> nxt ** filter_gt_7(nxt, preS1, postS1)
    }
| not (x == null) && preS =i {v} ++ preS1 && not (v > 7) => { [x, 1] ** x :-> nxt ** filter_gt_7(nxt, preS1, postS) }
}

// synonym foldMap2(loc x, set s, int acc, int z, pred mapFn, pred foldFn) {
//   
// }

// synonym pair_list(loc x, set lefts, set rights) {
//   spatially_constrained
// }

// predicate pairwise_sum(loc x, loc y, set s) {
// }

// synonym foldMap(loc x, set s, int acc, int z, pred mapFn, pred foldFn) {
//   join(foldI[x, s, acc, z, foldFn[_, ?mapResult, _]], constrained_list[x, s, mapFn[_, ?mapResult]])
// }

predicate subseq_of(loc xs, set subsetS, set s) {
| xs == null => { subsetS =i {} ; emp }
| not (xs == null) => {
    subsetS =i {v} ++ subsetS1 && v in s
      ;
    [x, 2] **
    x :-> v **
    (x+1) :-> nxt **
    subseq_of(nxt, subsetS1, s - {v})
  }
}

// predicate foldMap'(loc x, loc s, int acc, int z, pred mapFn, pred foldFn) {
// |  x == null => { acc == z ; emp }
// |  not (x == null) => {
//     s =i {v} ++ s1 && mapFn(v, mapResult) ; [x, 2] ** x :-> r ** (x + 1) :-> nxt ** constrained_list(nxt, s1, p)
//    }
// }


//    predicate foldMap_generated(loc x, set s, int acc, int z, pred mapFn, pred foldFn) {
//    | x == null => { acc == z && s =i {} ; emp }
//    | not (x == null) => {
//         s =i {v} ++ s1
//         && mapFn(v, mapResult)
//         && foldFn(acc, mapResult, acc1)
//           ;
//         [x, 2] ** x :-> mapResult ** (x + 1) :-> nxt ** foldMap_generated(nxt, s1, acc1, z, mapFn, foldFn)
//      }
//    }

predicate reify(loc x, int i) {
| true => { [x, 1] ** x :-> i }
}

predicate height_leaf_tree(loc x, set s, int height) {
| x == 0 => { height == 0 && s =i {} ; emp }
| not (x == 0) => {
    height =i (heightLeft <= heightRight ? heightRight : heightLeft) + 1 &&
    s =i sLeft ++ sRight
      ;
    [x, 2] **
    x :-> left **
    (x+1) :-> right **
    height_leaf_tree(left, sLeft, heightLeft) **
    height_leaf_tree(right, sRight, heightRight)
  }
}

predicate wrapped_height_leaf_tree(loc x, set s) {
| true => { x :-> height ** height_leaf_tree(x, s, height) }
}

predicate minHeight(loc x, set s, int height) {
| x == 0 => { height == 0 && s =i {} ; emp }
| not (x == 0) => {
    height =i (heightHere <= heightThere ? heightHere : heightThere)
    && b == (heightHere <= heightThere ? 1 : 0)
      ;
    [x, 2] **
    x :-> r **
    (x+1) :-> nxt **
    // cond(r, b, x1, nxt) **   // <- This violates the "separation condition"
    height_leaf_tree(x1, s, heightHere) **
    minHeight(nxt, s, heightThere)
  }
}

predicate cond(loc res, int c, loc t, loc f) {
| c == 0 => { res :-> f }
| not (c == 0) => { res :-> t }
}

predicate singleton_list(loc x, int n) {
| true => { [x, 2] ** x :-> n ** (x+1) :-> 0 }
}

// Unary representation of natural numbers
predicate natural(loc x) {
| x == null => { emp }
| not (x == null) => {
    [x, 2] **
    x :-> 0 ** // This is included so that we can use "list-style" functions
    (x+1) :-> nxt **
    natural(nxt)
  }
}

predicate foldL(loc x, loc acc, pred z, pred p) {
|  x == null => { z(acc) }
|  not (x == null) => {
    p(acc, v, nxtAcc) **
    [x, 2] ** x :-> v ** (x + 1) :-> nxt ** foldL(nxt, s1, nxtAcc, z, p) }
}

// map (x:) xs
predicate cons_map(int v, loc xsPtr, loc r) {
| r == null => { s =i {} ; emp }
| not (r == null) => {
    xsPtr :-> xs **
    (xsPtr+1) :-> xsPtrNxt **

    [ys, 2] **  // New cons cell
    ys :-> v **
    (ys+1) :-> nxt **
    r :-> ys **
    (r+1) :-> xsPtr **
    cons_map(x, xsPtrNxt, xsPtr)
  }
}

predicate list_of_lists(loc x, set s) {
| x == null => { s =i {} ; emp }
| not (x == null) => {
    s =i headS ++ s1
      ;
    sll(head, headS) **

    [x, 2] **
    x :-> head **
    (x+1) :-> nxt **
    list_of_lists(nxt, s1)
  }
}

predicate append(loc r, set sX, set sY, pred unused) {
| true => { constrained_list(r, sX ++ sY, pred(u, v) => u == v) }
}

