predicate transformation_list(loc x, set preS, set postS, pred p) {
|  x == null        => { preS =i {} && postS =i {} ; emp }
|  not (x == null)  => { preS =i {v} ++ preS1 && postS =i {r} ++ postS1 && p(v, r) ; [x, 2] ** x :-> r ** (x + 1) :-> nxt ** transformation_list(nxt, preS1, postS1, p) }
}

predicate list_relation(loc x, loc y, set preS, set postS, pred p) {
|  x == null       => { preS =i {} && postS =i {} && y == null ; emp }
|  not (x == null) => { preS =i {xV} ++ preS1 && postS =i {yV} ++ postS1 && p(xV, yV)
      ;
      [x, 2] ** [y, 2] ** x :-> xV ** y :-> yV ** (x+1) :-> xNxt ** (y+1) :-> yNxt **
      list_relation(xNxt, yNxt, preS1, postS1, p) }
}

predicate constrained_list(loc x, set s, pred p) {
|  x == null        => { s =i {} ; emp }
|  not (x == null)  => { s =i {v} ++ s1 && p(v, r) ; [x, 2] ** x :-> r ** (x + 1) :-> nxt ** constrained_list(nxt, s1, p) }
}

synonym unconstrained(loc x, set s) {
  constrained_list(x, s, pred(u, v) => u == v)
}

predicate foldI(loc x, set s, int acc, int z, pred p) {
|  x == null => { acc == z; emp }
|  not (x == null) => {
    p(acc, v, acc1) && s =i {v} ++ s1
      ;
    [x, 2] ** x :-> v ** (x + 1) :-> nxt ** foldI(nxt, s1, acc1, z, p) }
}

predicate foldMap(loc x, set s, int acc, int z, pred mapFn, pred foldFn) {
|  x == null       => { acc == z && s =i {} ; emp }
|  not (x == null) => {
     s =i {v} ++ s1 && mapFn(v, mapResult) && foldFn(acc, mapResult, acc1)
       ;
     [x, 2] ** x :-> v ** (x+1) :-> nxt ** foldMap(nxt, s1, acc1, z, mapFn, foldFn)
    }
}

// synonym foldMap(loc x, set s, int acc, int z, pred mapFn, pred foldFn) {
//   join(foldI[x, s, acc, z, foldFn[_, ?mapResult, _]], constrained_list[x, s, mapFn[_, ?mapResult]])
// }

// predicate foldMap'(loc x, loc s, int acc, int z, pred mapFn, pred foldFn) {
// |  x == null => { acc == z ; emp }
// |  not (x == null) => {
//     s =i {v} ++ s1 && mapFn(v, mapResult) ; [x, 2] ** x :-> r ** (x + 1) :-> nxt ** constrained_list(nxt, s1, p)
//    }
// }


//    predicate foldMap_generated(loc x, set s, int acc, int z, pred mapFn, pred foldFn) {
//    | x == null => { acc == z && s =i {} ; emp }
//    | not (x == null) => {
//         s =i {v} ++ s1
//         && mapFn(v, mapResult)
//         && foldFn(acc, mapResult, acc1)
//           ;
//         [x, 2] ** x :-> mapResult ** (x + 1) :-> nxt ** foldMap_generated(nxt, s1, acc1, z, mapFn, foldFn)
//      }
//    }

predicate reify(loc x, int i) {
| true => { [x, 1] ** x :-> i }
}

