predicate base(loc x, loc y, set ys){
| y == 0 => {ys == {} && x == 0 ; emp}
| not (y == 0)   => {y :-> vy ** inner(x, y, ys, vy)}
}

predicate inner(loc x, loc y, set ys, int vy){
|    vy < 1 => {ys == {vy} ++ ys1 ;
    [y, 2] ** y :-> vy ** (y + 1) :-> ynxt ** base(x, ynxt, ys1)}
|    not (vy < 1) => {ys == {vy} ++ ys1;
    [x, 2] ** x :-> vy ** (x + 1) :-> xnxt ** (y + 1) :-> ynxt ** base(xnxt, ynxt, ys1)}
}

predicate constrained_list(loc x, set s, pred p) {
|  x == null        => { s =i {} ; emp }
|  not (x == null)  => { s =i {v} ++ s1 && p(v, r) ; [x, 2] ** x :-> r ** (x + 1) :-> nxt ** constrained_list(nxt, s1, p) }
}

synonym unconstrained(loc x, set s) {
  constrained_list(x, s, pred(u, v) => u == v)
}