predicate constrained_list(loc x, set s, pred p) {
|  x == null        => { s =i {} ; emp }
|  not (x == null)  => { s =i {v} ++ s1 && p(v, r) ; [x, 2] ** x :-> r ** (x + 1) :-> nxt ** constrained_list(nxt, s1, p) }
}

synonym unconstrained(loc x, set s) {
  constrained_list(x, s, pred(u, v) => u == v)
}


predicate zip(loc ret, loc a, loc b, set aS, set bS){
|  ret == null => {aS == {} && bS == {} && a == null && b == null; emp }
|  not (ret == null) => { aS == {va} ++ aS1 && bS == {vb} ++ bS1;
[ret, 3] ** ret :-> va ** (ret+1) :-> vb **  (ret+2) :-> retNxt **
[a, 2] ** a:-> va ** (a+1) :-> anxt ** [b, 2] ** b:-> vb ** (b+1) :-> bnxt
 ** zip(retNxt, anxt, bnxt, aS1, bS1)
}
}


/*
predicate zip(loc ret, set aS, set bS){
|  ret == null => {bS == {} ; emp }
|  not (ret == null) => { bS == {vb} ++ bS1;
[ret, 3] ** ret :-> vb ** (ret+1) :-> vb **  (ret+2) :-> retNxt ** zip(retNxt, aS, bS1)
}
}
*/