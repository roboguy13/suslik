predicate constrained_list(loc x, set s, pred p) {
|  x == null        => { s =i {} ; emp }
|  not (x == null)  => { s =i {v} ++ s1 && p(v, r) ; [x, 2] ** x :-> r ** (x + 1) :-> nxt ** constrained_list(nxt, s1, p) }
}

synonym unconstrained(loc x, set s) {
  constrained_list(x, s, pred(u, v) => u == v)
}


predicate zip(loc ret, set aS, set bS){
|  ret == null => {aS == {} && bS == {} ; emp }
|  not (ret == null) => { aS == {va} ++ aS1 && bS == {vb} ++ bS1;
[ret, 3] ** ret :-> va ** (ret+1) :-> vb **  (ret+2) :-> retNxt ** zip(retNxt, aS1, bS1)
}
}


/*
predicate zip(loc ret, set aS, set bS){
|  ret == null => {bS == {} ; emp }
|  not (ret == null) => { bS == {vb} ++ bS1;
[ret, 3] ** ret :-> vb ** (ret+1) :-> vb **  (ret+2) :-> retNxt ** zip(retNxt, aS, bS1)
}
}
*/